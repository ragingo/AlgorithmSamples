name: "[cpp] CI (Manual & Comment-driven)"

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

# Automatic triggers disabled to save vCPU time
# on:
#   push:
#     branches: [ main ]
#     paths:
#       - 'cpp/**'
#       - '.github/workflows/cpp-ci.yml'
#   pull_request:
#     branches: [ main ]
#     paths:
#       - 'cpp/**'
#       - '.github/workflows/cpp-ci.yml'

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'cpp/**'
      - '.github/workflows/cpp-ci.yml'
  workflow_dispatch:
    inputs:
      target:
        description: 'Which jobs to run'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'build'
          - 'lint'
          - 'format'
          - 'coverage'
      reason:
        description: 'Reason for manual execution'
        required: false
        default: 'Manual testing'
  issue_comment:
    types: [created]

jobs:
  check-trigger:
    name: "Check Trigger"
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      should_lint: ${{ steps.check.outputs.should_lint }}
      should_format: ${{ steps.check.outputs.should_format }}
      should_coverage: ${{ steps.check.outputs.should_coverage }}
      trigger_source: ${{ steps.check.outputs.trigger_source }}
    steps:
      - name: Check trigger source
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            let should_build = false;
            let should_lint = false;
            let should_format = false;
            let should_coverage = false;
            let trigger_source = 'unknown';

            if (context.eventName === 'workflow_dispatch') {
              trigger_source = 'manual';
              const target = context.payload.inputs.target;
              should_build = target === 'all' || target === 'build';
              should_lint = target === 'all' || target === 'lint';
              should_format = target === 'all' || target === 'format';
              should_coverage = target === 'all' || target === 'coverage';
            } else if (context.eventName === 'pull_request') {
              trigger_source = 'pull_request';
              // PR作成時は軽量チェックのみ
              should_lint = true;
              should_format = true;
            } else if (context.eventName === 'issue_comment' && context.payload.issue.pull_request) {
              trigger_source = 'comment';
              const comment = context.payload.comment.body.toLowerCase().trim();
              const botMentions = ['@github-actions', '@github-actions[bot]', '/ci'];

              let mentioned = false;
              for (const mention of botMentions) {
                if (comment.includes(mention)) {
                  mentioned = true;
                  break;
                }
              }

              if (mentioned) {
                should_build = comment.includes('build') || comment.includes('ci_all');
                should_lint = comment.includes('lint') || comment.includes('ci_all');
                should_format = comment.includes('format') || comment.includes('ci_all');
                should_coverage = comment.includes('coverage') || comment.includes('ci_all');

                // コメントに🚀リアクション
                if (should_build || should_lint || should_format || should_coverage) {
                  await github.rest.reactions.createForIssueComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: context.payload.comment.id,
                    content: 'rocket'
                  });
                }
              }
            }

            core.setOutput('should_build', should_build);
            core.setOutput('should_lint', should_lint);
            core.setOutput('should_format', should_format);
            core.setOutput('should_coverage', should_coverage);
            core.setOutput('trigger_source', trigger_source);

  cpp-build-and-test:
    name: "[cpp] Build & Test"
    runs-on: ${{ matrix.os }}
    needs: check-trigger
    if: needs.check-trigger.outputs.should_build == 'true'
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - name: Get PR branch (for comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/github-script@v7
        id: get-pr
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              ref: pr.head.ref,
              sha: pr.head.sha
            };

      - name: Checkout (comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/checkout@v4
        with:
          ref: ${{ fromJson(steps.get-pr.outputs.result).ref }}

      - name: Checkout (manual trigger)
        if: needs.check-trigger.outputs.trigger_source == 'manual'
        uses: actions/checkout@v4

      - name: Setup CMake (with cache)
        id: cmake
        uses: lukka/get-cmake@latest
        with:
          cmakeVersion: '~4.1.0'
          useCloudCache: false
          useLocalCache: true

      - name: Cache CMake build
        uses: actions/cache@v4
        with:
          path: |
            cpp/build
            ~/.cmake
          key: cmake-build-${{ matrix.os }}-${{ hashFiles('cpp/CMakeLists.txt', 'cpp/**/CMakeLists.txt') }}
          restore-keys: |
            cmake-build-${{ matrix.os }}-

      - name: Configure
        run: cmake -S cpp -B cpp/build -DBUILD_TESTS=ON

      - name: Build
        run: cmake --build cpp/build --config Release -j 4

      - name: Run tests (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          chcp 65001
          cd cpp/build
          ctest -C Release --output-on-failure
        shell: cmd

      - name: Run tests (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          cd cpp/build
          ctest -C Release --output-on-failure
        env:
          LC_ALL: C.UTF-8

      - name: Upload test results (Linux)
        if: always() && matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}
          path: cpp/build/Testing/Temporary/LastTest.log

  report-build-results:
    name: "Report Build Results"
    runs-on: ubuntu-latest
    needs: [check-trigger, cpp-build-and-test]
    if: always() && needs.check-trigger.outputs.should_build == 'true' && needs.check-trigger.outputs.trigger_source == 'comment'
    steps:
      - name: Comment build results summary
        uses: actions/github-script@v7
        with:
          script: |
            const buildJobs = ${{ toJson(needs.cpp-build-and-test) }};
            const results = buildJobs.result;

            let summary = '## 🏗️ Build & Test Results\n\n';

            const platforms = ['ubuntu-latest', 'windows-latest', 'macos-latest'];
            const platformNames = {
              'ubuntu-latest': 'Ubuntu',
              'windows-latest': 'Windows',
              'macos-latest': 'macOS'
            };

            let allSuccess = true;

            for (const platform of platforms) {
              const emoji = results === 'success' ? '✅' : '❌';
              const status = results === 'success' ? 'Success' : 'Failed';
              summary += `- ${emoji} **${platformNames[platform]}**: ${status}\n`;

              if (results !== 'success') {
                allSuccess = false;
              }
            }

            summary += '\n';
            summary += allSuccess ?
              '🎉 All platforms built and tested successfully!' :
              '⚠️ Some builds failed. Please check the workflow logs for details.';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: summary
            });

  cpp-format-check:
    name: "[cpp] Format Check"
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_format == 'true'
    steps:
      - name: Get PR branch (for comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/github-script@v7
        id: get-pr
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              ref: pr.head.ref,
              sha: pr.head.sha
            };

      - name: Checkout (comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/checkout@v4
        with:
          ref: ${{ fromJson(steps.get-pr.outputs.result).ref }}

      - name: Checkout (manual trigger)
        if: needs.check-trigger.outputs.trigger_source == 'manual'
        uses: actions/checkout@v4

      - name: Cache clang-format
        uses: actions/cache@v4
        with:
          path: ~/.cache/clang-format
          key: clang-format-${{ runner.os }}

      - name: Install clang-format
        run: |
          sudo apt update
          sudo apt install -y clang-format

      - name: Check format
        run: |
          cd cpp
          bash scripts/check-format.sh > ../format_output.txt 2>&1 || true

      - name: Comment format result (for comment trigger)
        if: always() && needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const formatOutput = fs.readFileSync('./format_output.txt', 'utf8');
            const success = !formatOutput.includes('Error') && !formatOutput.includes('would be reformatted');

            const emoji = success ? '✅' : '❌';
            const status = success ? 'All files are properly formatted' : 'Format issues found';

            let body = `${emoji} **Format Check**: ${status}`;

            if (!success) {
              body += '\n\n```\n' + formatOutput.trim() + '\n```';
              body += '\n\n💡 Run `bash cpp/scripts/format.sh` to fix formatting issues.';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

  cpp-lint:
    name: "[cpp] Lint Check"
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_lint == 'true'
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Get PR branch (for comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/github-script@v7
        id: get-pr
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              ref: pr.head.ref,
              sha: pr.head.sha
            };

      - name: Checkout (comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/checkout@v4
        with:
          ref: ${{ fromJson(steps.get-pr.outputs.result).ref }}

      - name: Checkout (manual trigger)
        if: needs.check-trigger.outputs.trigger_source == 'manual'
        uses: actions/checkout@v4

      - name: Check if CMake already available
        id: check-cmake
        run: |
          if command -v cmake &> /dev/null && cmake --version | grep -q "4\.[1-9]"; then
            echo "cmake_available=true" >> $GITHUB_OUTPUT
            echo "Using system CMake: $(cmake --version)"
          else
            echo "cmake_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup CMake (only if needed)
        if: steps.check-cmake.outputs.cmake_available != 'true'
        uses: lukka/get-cmake@latest
        with:
          cmakeVersion: '~4.1.0'
          useCloudCache: false
          useLocalCache: true

      - name: Cache lint dependencies
        uses: actions/cache@v4
        with:
          path: |
            cpp/build/compile_commands.json
            ~/.cache/clang-tidy
          key: lint-deps-${{ hashFiles('cpp/**/*.cpp', 'cpp/**/*.hpp', 'cpp/CMakeLists.txt') }}
          restore-keys: |
            lint-deps-

      - name: Install clang-tidy
        run: |
          sudo apt update
          sudo apt install -y clang-tidy build-essential

      - name: Configure CMake (minimal for lint)
        run: |
          # Only generate compile_commands.json, skip full configuration
          if [ ! -f cpp/build/compile_commands.json ]; then
            cmake -S cpp -B cpp/build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTS=OFF
          fi

      - name: Run clang-tidy and generate report
        run: |
          chmod +x cpp/scripts/lint.sh cpp/scripts/lint-pr.sh
          cd cpp && bash scripts/lint-pr.sh

      - name: Comment lint results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = './cpp/pr_lint_summary.md';

            if (fs.existsSync(path)) {
              const comment = fs.readFileSync(path, 'utf8');

              if (context.eventName === 'issue_comment') {
                // For comment trigger, just create a new comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              }
            }

  cpp-coverage:
    name: "[cpp] Coverage"
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_coverage == 'true'
    steps:
      - name: Get PR branch (for comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/github-script@v7
        id: get-pr
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              ref: pr.head.ref,
              sha: pr.head.sha
            };

      - name: Checkout (comment trigger)
        if: needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/checkout@v4
        with:
          ref: ${{ fromJson(steps.get-pr.outputs.result).ref }}

      - name: Checkout (manual trigger)
        if: needs.check-trigger.outputs.trigger_source == 'manual'
        uses: actions/checkout@v4

      - name: Check if CMake already available
        id: check-cmake
        run: |
          if command -v cmake &> /dev/null && cmake --version | grep -q "4\.[1-9]"; then
            echo "cmake_available=true" >> $GITHUB_OUTPUT
            echo "Using system CMake: $(cmake --version)"
          else
            echo "cmake_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup CMake (only if needed)
        if: steps.check-cmake.outputs.cmake_available != 'true'
        uses: lukka/get-cmake@latest
        with:
          cmakeVersion: '~4.1.0'
          useCloudCache: false
          useLocalCache: true

      - name: Cache coverage build
        uses: actions/cache@v4
        with:
          path: |
            cpp/build-coverage
            ~/.cache/lcov
          key: coverage-${{ hashFiles('cpp/CMakeLists.txt', 'cpp/**/CMakeLists.txt') }}
          restore-keys: |
            coverage-

      - name: Install lcov
        run: |
          sudo apt update
          sudo apt install -y lcov

      - name: Configure with coverage flags
        run: |
          cmake -S cpp -B cpp/build-coverage -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="--coverage" -DCMAKE_C_FLAGS="--coverage"

      - name: Build tests
        run: cmake --build cpp/build-coverage --config Debug -j 4

      - name: Run tests (coverage)
        run: |
          cd cpp/build-coverage
          ctest -C Debug --output-on-failure

      - name: Capture coverage
        run: |
          lcov --capture --directory cpp/build-coverage --output-file coverage.info --ignore-errors source,gcov || true
          lcov --remove coverage.info '/usr/*' '*/_deps/*' '*/tests/*' --output-file coverage.info --ignore-errors empty || true

          # Get coverage percentage
          COVERAGE=$(lcov --summary coverage.info 2>/dev/null | grep "lines" | grep -o '[0-9.]*%' || echo "0%")
          echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV

      - name: Comment coverage result (for comment trigger)
        if: always() && needs.check-trigger.outputs.trigger_source == 'comment'
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = process.env.COVERAGE;
            const emoji = parseFloat(coverage) >= 80 ? '✅' : '⚠️';

            const body = `${emoji} **Coverage**: ${coverage}

            📊 Code coverage analysis completed. ${parseFloat(coverage) >= 80 ? 'Great coverage!' : 'Consider adding more tests.'}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: coverage.info
          fail_ci_if_error: false
